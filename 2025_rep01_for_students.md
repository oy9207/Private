# 回答用紙 

(本Markdownファイルを記入し、課題を完成、提出する)

###  プログラミングII　2025　課題レポート（第1回）
###  提出期限：　2024/10/17(金) 17:00

-------

レポート提出者：

|クラス|学籍番号|　氏名　|
|-|-|-|
|A| 20125004 | 大野　悠豊 |


-----

##  問題１ リスト、タプル、計算式　【通常問題、回答必須】

|空欄|適切なコードに書き換えてください|
|-|-|
|(1)|my_tuple = (1,3,5,7)
index =0
for items in my_tuple:
    print(items)
    index +=1|

|(2)|my_tuple = (1,3,5,7)
result =((my_tuple[3]-my_tuple[1])+my_tuple[0])+my_tuple[2]
print(result)|

|(3)|ten =(2*2.5)+(100/20)/1
print(int(ten))|

|(4)|ten=(2*2.5)+(100/20)/1
assert ten==10
print("tenは10です")|

|(5)|ten=(2*2.5)*(100/20)/1
assert ten==10|

###  問題1 (1)  
    1,1,9,9 を使って10をつくる

```python
try:
   a,b,c,d = [1,1,9,9]
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten =  int(((c+d)/(a+b))+1)
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
   raise e
```

    ゼロで割ったら無限大, so let's try it again
    division by zero

    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    <ipython-input-9-eb664ac7535b> in <cell line: 1>()
         11    print(f"ゼロで割ったら無限大, so let's try it again");
         12    print(e);
    ---> 13    raise e
    

    <ipython-input-9-eb664ac7535b> in <cell line: 1>()
          2    a,b,c,d = [1,1,9,9]
          3    # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
    ----> 4    ten = int(  10/0   )  #  10/0は間違い　→　10を作る計算式に書き換えて
          5    assert ten == 10, f"Ten is {ten}, not 10"
          6    print(f"Ten is {ten}, {ten} == 10.")


    ZeroDivisionError: division by zero


###  問題1 (2)  
    3, 4, 6, 6 を使って10をつくる

```python
try:
   a,b,c,d = (3, 4, 6, 6,)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten =  int(c+d)-(c-b)
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (3)  
    4,6,6,9 を使って10をつくる



```python
try:
   a,b,c,d = (4, 6, 6, 9)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten =  int(d+c)-(d-a)
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (4)  
    9,9,9,9 を使って10をつくる


```python
try:
   a,b,c,d = (9, 9, 9, 9)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten =int((a*b)+c)/d

   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


###  問題1 (5)  
    1, 1, 5, 8 を使って10をつくる

```python
try:
   a,b,c,d = (1, 1, 5, 8)
   # ten = 計算式 を作成して、ten = 10になる計算式を組み立てる
   ten = int(d+c-(a+b+a)) 
   assert ten == 10, f"Ten is {ten}, not 10"
   print(f"Ten is {ten}, {ten} == 10.")
except AssertionError as e:
   print(f"惜しい!  try again");
   print(e);
except ZeroDivisionError as e:
   print(f"ゼロで割ったら無限大, so let's try it again");
   print(e);
```

    Ten is 10, 10 == 10.


##　問題１の理解度確認のための説明文

問題１で使った技法（お宝アイテム）について、**自分の言葉で**,価値や利益を説明してください：

- タプルはどういう役割で使いましたか？
- リストはどういう役割で使いましたか？
- try: except: 例外処理は何のために使いましたか？
- assertは何の役割で使いましたか？
- ten = int()のint()は、何の役割で使いましたか？

|データ構造、制御|役割、価値|
|-|-|
|タプル|値を取り出すときに値をタプルを使ってグループ化した|
|リスト|リストにすることで中の値を変更したり、追加、削除することができる|
|例外処理|上のコードの場合答えが違うとエラーが起き途中で止まってしまうので、例外処理を使ってエラーが起きても止まらないようにした|
|assert|四則演算で計算したときその計算式が求めようとしている答えなのか確認するため|
|int()|assertで10に等しいか確認する時、計算したままだと10.0なので整数にするためにintを使った|



----------
----------

## 問題２： 内包表現　【通常問題、回答必須】

#### 問題2-1

下記問題の4つの空欄A,B,C,Dに、適切な計算式をPythonコードで記述する

|空欄|適切なコードに書き換えてください|
|-|-|
|(1)|cubes =[x**3 for x in range(10)]
print(cubes)|

|(2)|odd_numbers = tuple (x for x in range(10,21) if x % 2 !=0)
print(odd)|

|(3)|string = "Hello World."
char_to_unicode = {char: ord(char) for char in string}
print(char_to_unicode)|

|(4)|numbers = [3, -1, -5, 8, 0, -3, 7]
negative_set = {x for z in numbers if x < 0}|

-----

リスト、タプル、辞書、集合の内包表記を使って、以下のデータ構造を作成してください：

1. `0`から`9`までの整数の立方数を含むリスト

2. `10`から`20`までの整数のうち奇数を含むジェネレータをタプルに変換

3. 任意の文字列の各文字をキー、文字のUnicodeコードポイントを値とする辞書

4. 任意の数値のリストから、負の数のみを含む集合


```python
# 1. 立方数リスト
cubes = [ '空欄A' ]
```


```python
# 2. 奇数のジェネレータからタプル
odd_numbers = tuple( '空欄B' )
```


```python
# 3. 文字列の文字をキー、Unicodeコードポイントを値とする辞書
string = "Hello World."
char_to_unicode = { '空欄C' }
```


```python
# 4. 負の数のみの集合
numbers = [3, -1, -5, 8, 0, -3, 7]
negative_set = { '空欄D' }
```

----------
----------

## 問題３： Class、メソッド、インスタンス

#### 問題3-1:  ロジックの穴埋め、動作確認
- 次のコードの３つの空欄A,B,Cに、適切なコードを記述する

|空欄|適切なコードに書き換えてください|
|-|-|
|A|n//2|
|B|3*n+1|
|C|n|

- 動作確認：　期待するアウトプットを出力することを確認する

    - 期待する出力
          [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
          35
          [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
          10
          [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
          86

- 次の質問について、**自分の言葉で**　考えを説明する：

    - この例で，クラスの定義は、どこからどこまで、どのように設計されていますか？
    ```
      クラスの定義はclass collatzから始まり、__init__,calc,__len__の3つのメゾットが含まれている。
      設計はコラッツ数列を生成しその長さを取得すること。
    ```
    - この例で，メソッドの定義は、いくつあって、どれとどれで、どのように設計されていますか？
    ```
      メゾットの定義は__init__,generate,lengthの3つがあります。
      設計は__init__はスタートを受け取りスタート地点を保存する。calcは数列のルールに従って1になるまで数列を作る。__len__はcalcで作った数列の長さを返す。
    ```

    - この例で，インスタンスは、どれですか？　どうやって作られて、どこに実体がありますか？
    ```
      インスタンスはc=collatz(n)の部分で作られていて、collatz(n)によって__init__が呼び出されcというインスタンスが作られた
    ```

    - インスタンスに対して、メソッドを呼び出しているのはどこですか？
    ```
      C.calc()とlen(C)です。
      C.calc()は数列を作ったメゾットを呼び出して結果を表示された。
      len(C)は__len__が呼び出されて数列の長さが表示された。
    ```


```python
### Collatzクラスとメソッドを設計・定義する

class Collatz:
  def __init__(self, n):
    self._seq = [n]

  def calc(self):
    n =  self._seq[-1]
    while n !=1:
      n = ('空欄A') if n%2==0 else ('空欄B')
      self._seq.append(n)
    return self._seq

  def __len__(self):
    return len(self._seq)

### Collatzクラスのインスタンスを作って、メソッドを使う

Ns = [237, 512, 31415]

for n in Ns:
  C = Collatz('空欄C')
  print(C.calc())
  print(len(C))

```

    [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    35
    [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
    10
    [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    86


##### 問題3-2 [Extra　Challenge]　チャレンジ問題：ジェネレータ

|空欄|適切なコードに書き換えてください|
|-|-|
|D|n|
|E|n|
|F|C.calc()|

```python

class Collatz:
    def __init__(self, n):
        self.n = n

    def calc(self):
        n = self.n
        while n != 1:
            yield ('空欄D')
            n = n // 2 if n % 2 == 0 else 3 * n + 1
        yield ('空欄E')

Ns = [237, 512, 31415]
for d in Ns:
  C = Collatz(d)
  seq = [ n for n in ('空欄F') ]
  print(len(seq))
  print(seq)

```

    35
    [237, 712, 356, 178, 89, 268, 134, 67, 202, 101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    10
    [512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
    86
    [31415, 94246, 47123, 141370, 70685, 212056, 106028, 53014, 26507, 79522, 39761, 119284, 59642, 29821, 89464, 44732, 22366, 11183, 33550, 16775, 50326, 25163, 75490, 37745, 113236, 56618, 28309, 84928, 42464, 21232, 10616, 5308, 2654, 1327, 3982, 1991, 5974, 2987, 8962, 4481, 13444, 6722, 3361, 10084, 5042, 2521, 7564, 3782, 1891, 5674, 2837, 8512, 4256, 2128, 1064, 532, 266, 133, 400, 200, 100, 50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]


---
---

## 問題４

### **Stack クラスと Queue クラスの設計と実装**

#### 問題4-(1): ユースケースの比較
- スタックとキューは、さまざまなシーンで使われる有用なデータ構造です．
- 次のユースケースごとに、`Stack` と `Queue` のどちらがより適切か選択し、その理由を説明してください:

1. Web ブラウザーの戻るボタン機能：
   - `Queue` が適切
   - なぜならばQueueは古いものを取り出すことができるから、戻るボタンを押して古いデータを読み込見込めるから適切。

2. オフィスのプリンタのジョブ：
   - `Queue` が適切
   - 印刷機は複数の人から依頼され送られた順番に処理する必要があります。そのため後ろの人から処理できるQueueが適切だと考える。

3. 括弧を含む数式の評価 (例: `((1 + 2) * 3)`)：
   - `Stack`  が適切
   - Stackは最後に入れたものを最初に取り出すという性質があります。  
   この式 ((1 + 2) * 3) の場合、まず外側の括弧が開かれ、次に内側の (1 + 2) が開かれます。  
   計算するときは、最後に開いた括弧から順に計算されるため、スタックが適切
  
---
#### 問題4-(2): Pythonクラス設計

- 基本的なスタック機能とキュー機能を実装する Python クラス `Stack` とクラス `Queue` を設計して, Pythonで記述してください
   
- クラスには，少なくとも次のメソッドを含める必要があります:
- `Stack` : `push()`,`pop()`,`is_empty()`
- `Queue` : `enqueue()`,`dequeue()`,`is_empty()`

- 空の状態にも関わらず，データを取り出そうとするケース：pop()またはdequeue()などのエッジケース(例外処理)に対応してください

---
```python

class Stack:
   """
   """
   def __init__(self):
      self.items =[]
   
   def push(self,data):
      self.items.append(data)

   def pop(self):
      if self.is_empty():
         raise IndexError("スタックが空です")
      return self.items.pop()

   def is_empty(self):
      return len(self.items) ==0

```

```python

class Queue:
   """
   """
   def __init__(self):
      self.items =[]
   
   def enqueue(self,data):
      self.items.append(data)

   def dequeue(self):
      if self.is_empty():
         raise IndexError("キューが空です")
      return self.items.pop(0)

   def is_empty(self):
      return len(self.items) ==0    

```
---
#### 問題4-(3): 動作確認，実装のテスト (コード実行)

`Stack` クラスと `Queue` クラスを設計しコードを記述したら，次は動作確認です．
期待した動作ができているか，次の操作でコードをテストしてください:

1. **Stack**:
- スタックに 5 つの要素をプッシュします (例: `[1、2、3、4、5]`)
- スタックが空になるまで、一連のポップ操作を実行します
- is_empty()で空かどうかチェックします
- 空のスタックから再度 `pop()` を試し、例外処理を確認します

1. **Queue**:
- 5 つの要素をキューに追加します (例: `[1, 2, 3, 4, 5]`)
- キューが空になるまで、一連のデキュー操作を実行します
- is_empty()で空かどうかチェックします
- 空のキューから再度 `dequeue()` を試し、例外処理を確認します



---
#### 問題4-(4): [Extra　Challenge]　チャレンジ問題：スタックとキューによる応用

- `Queue` オブジェクトを引数として受け取り、要素を逆順にした新しいキューを返す関数 `reverse_queue(q: Queue)` を記述してください
- 実装した `Queue` クラスと `Stack` クラスのみ使用できます
- それ以外，リストや配列などの追加のデータ構造は使用できません
---

